0:00
本视频会详细讲解 快速排序算法的实现 尤其是如果你想研究 最关键的Partition(分区)子程序 所以回顾在数组排序中 Partition子程序负责的工作 那么 还记得快速排序的主要思路是 围绕主元元素将输入数组分区 这分为两步 首先 你总要选一个主元元素 在这个视频中 我们不担心 你如何选择这个主元元素 谨慎起见 你可以先考虑 选择这个数组中的第一个元素 作为主元元素 在这个数组的例子中 第一个元素恰好是3 所以我们可以选择 3作为主元元素 现在 有个重要的重排的步骤 你们重新给数组排序以便于它有如下性质 主元元素左边的任意元素 必须小于基准元素 而主元元素右边的元素 必须大于主元元素 例如 在这个数组 在第二个数组里 我们看到 3左边 是 2和 1 他俩顺序颠倒了 但是没关系 1和 2都在 3的左边 并且他们都小于3 而 3右边的五个元素 他们虽然杂乱无章 但是都比主元元素大 这步重排满足了分区的性质 因此很合理 再回想一下 这一定能使数组 局部变得有序 主元元素回归到它正确的位置 它回归到 在最终排序后数组中 应该所处的位置 右边的所有元素 都小于它 左边的所有元素都比它大 此外 我们根据 其他 N -1个元素 在最终排序后数组中 应该所处的位置 将他们正确地 放到主元元素左右两边的桶里 那么这就做完了 这就是Partition子程序的工作 现在 很有趣的是我们 将用线性时间复杂度来实现Partition子程序 我们甚至可以实现地更好 就是所有的工作真的只通过 数组中元素互换来实现 即原地做 不需要多余的实质的常量的 额外存储空间 就可以根据那些性质重排数组 接着 正如我们所了解的对快速排序算法 的抽象概念 分区的目的 就是便于使用分治法 这化简了问题 在你们围绕主元元素将数组分区后 要做的就是 在左边递归 在右边递归 就结束了 那么我还欠这个的实现 实际操作中 你们如何满足分区的性质 即主元元素左边的比它小 右边的 比它大 在线性时间内 并且原地实现 首先 我们观察 如果我们不在意原地实现的要求 如果我们愿意只是 再分配一个数组 拷贝所有的元素过去 线性时间内实现Partition子程序 将会变得非常简单 即用O(N)的额外内存 线性时间内 围绕一个主元元素分区 非常简单 通常 我可能应该写的更准确 用theta N 用在更精准更有力的陈述里 但是我打算粗略一点 我打算只写大O 弱一些但仍是正确的陈述 好吗 那么是O(N)时间 使用线性额外内存 所以你们打算怎么做 让我先粗略用例子阐述一下 我想你们就明白了 让我们回到正在运行的输入数组 如果允许使用 线性额外空间 我们可以率先 分配另一个长度为N的数组 
3:18
接着我们可以简单扫描输入数组 根据他们相对主元元素的大小 把元素扔到桶里 例如 我们可以分别从左右两端填数组 通过比主元元素小或者比它大的元素 例如我们从8开始 已知8大于主元元素 则把它放到输出数组的末尾 接着我们看2 2小于主元元素 因此应该放到 输出数组的左边 5应该接着放到右手边 1应该接着放到左手边 以此类推 当我们输入数组扫描结束 还剩一个空位 即是主元元素所属于的位置 这个位置的右边全比它小 左边全比它大 接下来 真正有趣的是 在线性时间内 并且不用实质额外的空间 来实现分区 并不是用这种事先分配 一个长度为N的额外数组来做 让我们看一下怎么做 首先从抽象概念开始 然后再填充细节 我打算只描述这个Partition子程序 针对主元元素是第一个元素的情况 但这实际上 并不缺少普适性 其实如果你想选的主元元素在数组中间 你可以在预处理阶段 互换数组第一个元素 和已知的主元元素 接着运行我描述的这个子程序 好 预处理的时间是常数 随机主元元素的情况化简为 主元元素为第一个元素 因此这个抽象思路就是 很棒的 这个思路就是我们可以脱离 单纯地线性扫描输入数组 在开始扫描的时候 这是一个简单的for循环 我们追踪 数组里我们已经访问过的部分 和还没有访问的部分 因此 会有两个组 我们访问的 和还没访问的 然后在我们访问过的组里 我们将进一步根据 元素相对于主元元素的大小 对他们进行分割 所以在算法结束之前 我们先不管 数组第一个位置上的主元元素 到时候我们再用互换把它调整到正确位置 在算法的线性扫描中 我们会有 一些我们访问过的元素 和一些我们还没有访问过的元素 当然 我们不知道那些 还没有访问过的元素 是什么样的 谁知道他们是大于 还是小于主元元素 但是我们要在那些访问过的元素里 实现算法 把它分区 所有小于主元元素的放前面 所有大于它的放后面 通常我们不关心那些小于主元的元素 或者大于主元的元素的相对顺序 总结来讲 我们对输入数组做了一个简单的扫描 巧妙之处是 在整个线性扫描中以下保持不变 但是基本上 我们访问过的数组的 所有元素都被分割了 所有比主元小的排在 所有比主元大的前面 我们想保持这些不变 在线性扫描的每一步里 只做常量的工作  不用额外空间 那么下面是我接下来要做的 我会讲解一个例子 在一个实际的数组上运行Partition子程序 就用我们之前见过那个例子的数组 在我给你们算法 给你们代码之前 就给一个例子 可能有点奇怪 但是 我认为通过这种方式 你们能看到这个例子里的要点 等会当我给出代码的时候 就会很清晰了 但是如果我先给出代码 当我给你们算法的时候 可能会有点晦涩 所以我们先看一个例子 通过这个例子 我们会记住 在前一张幻灯片里 讲过的抽象概念 我们的目的在于 在Partition程序运行中 始终保持主元在第一个元素处 接着 我们得到 还没有访问过的那些元素 显然没人知道那些元素 大于还是小于主元 然后 对于我们访问过的那些元素 所有小于主元的排在所有 大于主元的前面 这就是当我们做线性扫描时 想要保持的 正如抽象概念所说 整个算法中我们需要监测两个边界 我们要监测的一个是 我们访问的和 没访问过元素的分界线 那么我们要做的是 用序号j追踪那个分界线 接着 我还追踪的第二个边界是 在我们见过的元素中 区分小于主元和大于主元元素的分界线 这个用i 让我们运行一下示例数组 刚开始的时候 事情很简单 我们还没有访问任何元素 因此所有的元素还未被分区 i和j均指向主元和其余元素之间的边界 为了得到线性运行时间 我们想要保证每当j前进一步的时 我们都访问一个新的元素 通过线性步数 我们将会访问所有元素 并且如我们所希望的 这样就结束了 并且得到一个分割过的数组 所以接下来我们向前移动j 数组中还未访问的 没被分割的区域 比原来小了一个 我们已经访问过8 主元后的第一个元素 
9:04
现在8自己实际上是一个分割过的数组 所有比主元小的排在前面 主元后面的结果显示 没有比主元小的 所以这分区实际没什么意义 j是访问过和未访问过元素之间的分界线 i是在访问过的元素里 大于和小于主元之间的分界线 8大于主元 因此i应该指向这 好 因为我们想要i刚好指向 所有大于主元的左边 那么下一步的迭代会发生什么呢 这里事情就有趣了 假设我们把j向前移动一步 现在我们访问过的这部分数组 2跟在8后面 现在8和2组成一个未分割的子数组 还记得分割过的数组是什么样吗 所有小于主元的元素 所有小于3的元素 应该排在所有大于3的后面 因此(8 2)显然不符合那个性质 2小于主元 但是却在8后面 8是大于主元的 为了更正这里 我们要做交换 我们交换2和8 就会得到原数组下面的这个版本 那么现在我们还没访问的元素 比之前少了一个 我们把j向前移动了一步 所有的未访问元素都还没分割 谁知道那些元素会发生什么 j向右移动了一步后 至少当我们做了交换后 我们的确得到一个分割好的数组 交换之后 2和8的确被分好了 现在 记住i是在已访问过的元素中 小于主元 这里是小于3 和大于主元的分界线 所以i要插在2和8之间 下一步迭代就很简单了 这一步 向前移动j 我们得到一个大于主元的元素 当我们得到8时 是第一步迭代 这和刚刚一步我们得到2时不同 这种情况 相比于第一次迭代 第三次迭代更接近与第一次迭代 尤其是 我们不需要交换 我们不需要向前移动i 我们只需要向前移动j就好了 我们看看这样为什么对 我们向前移动了一步j 完成了一步迭代 现在未访问的元素只剩下四个了 谁知道未访问过的是什么情况呢 但是如果你看我们访问过的 2 8和5 这事实上已经分割好了 对吗 所有大于3的数成功放在 所有小于3的后面 所以j划分访问和未访问的界限 在5和1之间 i划分小于和大于主元的界限在2和8之间 就像之前那样 把5添在末尾没有引起任何改变 让我们在下一张幻灯片 接着看这个例子 首先记住上一页我们离开的位置 因此我要把三次迭代算法后 那一步重画一下 注意 在下一次迭代里 如果要保留变量 我们还要对数组做一些调整 原因是当我们向前移动j 当我们扫描到1 我们又扫描到一个 小于主元的新元素 这意味着 分割好的区域 或者说我们已经访问过的区域 成为未分割的 我们有2851 记住我们需要所以小于3的 位于所有大于3的元素之前 这里末尾的1并不能当分界线 所以我们必须要交换 我们要交换什么呢 我们要交换1和8 为什么要交换1和8 显然我们需要把1和什么元素交换一下 为什么 因为数组最左边的元素 现在大于主元 就是8 好 这是第一 最左边的元素大于3 所以如果我们把1和它交换 1会成为小于3的最右边的元素 所以交换后 我们得到如下数组 未访问的元素是4 7和6 
13:37
那么j要在8和4之间 我们访问过的元素是2 1 5和8 注意这是的确已经分割好的 所有小于3的 2和1 位于所有大于3的元素 5和8之前 记住i应该划分小于3和大于3 元素之间 所以应该插在1和5之间 这比上一步迭代向右移动了一步 好 因为剩下的未访问元素 4 7和6都比主元大 最后三次迭代很简单 不再需要交换 不需要向前移动i 只需要移动j直到数组出界 快进一下 Partition子程序 或者说这个主要的线性扫描 会以如下情况结束 这时所有的元素都被访问过 所有的元素都被划分 j实际已经出界 i划分在小于主元和大于主元的元素之间 仍然在1和5之间 现在我们还不算结束 因为主元元素3不在正确的位置 记住我们的目的是得到一个数组 所有小于主元的元素排在它的左边 所有大于主元的数组排在它的右边 但是现在主元仍然停留在第一个位置 所以我们必须把它交换到正确位置 哪里是正确位置 是小于主元的最右边的元素 所以在这里 是1 所以算法会以如下数组结束 12358476 的确如我们所愿 所有在主元左边的都小于主元 所有在主元右边的都大于主元 1和2恰巧按照顺序排列 但这只是有点巧合 4 5 6和7 8你会发现是杂乱的 他们不按照顺序排列 如我们所愿通过这个例子 你们能了解通常情况下 Partition子程序工作的要点 但是为了保证细节也清楚 我现在给出分区算法的伪代码 我下面会给出 这会有一个输入数组 但并不需要明确的数值 而会把两个数组序号传入子程序 最左的序号 即你们应该操作的界限部分 和最右的序号 我这样写的原因是 快速排序算法会递归调用Partition(子程序) 所以在快速排序的每一步 我们都会递归求解某个子集 原输入数组的相邻子集 "l(el)"和"r"标记了 子数组的左边界和右边界 我们不要忘记这个算法 要保持循环不变量的抽象概念 如我们讨论的 我们假设主元元素是第一个元素 虽然这并不有失普适性 在任意时间点 会有未访问的元素 谁知道那些是怎么样的 在已访问的元素中 要维持循环不变量 即所有小于主元的位在 大于主元元素的前面 "j"和l分别代表已访问和未访问之间的界限 和元素大小之分的界限 回到伪代码 初始化数组第一个元素为主元 再回忆一下 l标记即将访问的最左边的序号 "i"初始化的值 应刚好是主元的右边 所以是el+1 "j"在主for循环中 也初始化为同样值 所以在这个for循环中 "j"从el+1遍历到最右序号"r" 即线性扫描了整个输入数组 我们发现本例出现两种情况 根据刚访问到的元素是大于主元 还是小于主元 简单情况是当它大于主元时 我们基本不用做任何事 记住 我们没做任何交换 我们没有改变"i" 边界没有变 当新元素小于主元时 我们才需要操作 所以我们要检查 新访问元素 A[j] 是否小于"p" 如果大于 我们实际上不需要做任何调整 那么让我先备注 如果新元素大于主元元素 我们不操作 显然每次for循环结束时 如果我们遍历的元素均大于"p" 只有j的值在改变 那么当我们遍历新元素小于p 应该做什么 我们要做两件事情 对于小于"p"的新元素 我用粉色圈出 我们需要重排目前访问过的元素 以便于得到分割好的新子数组 最好的办法是把新元素和大于主元元素 的最左边的数交换 因为"i"记录的是小于和大于 主元元素之间的分界线 我们能够立即得到 比主元大的最左边元素 这是数组第"i"个元素 坦诚而言 我在这里略施小计 有种情况是所有元素都小于等于主元元素 那么你实际没有可以交换的 大于主元的最左元素 结果是这个代码仍然好用 我会证实给你们 但一些交换操作的确有些冗杂 其实当你访问到一些元素大于主元 而后一些元素小于主元 这时再做交换就行 你可以想象这个的区别是 你实际要记录这种情况是否发生 以避免多余的交换 我只会给你们伪代码 直觉上 你要考虑这个例子 就像蓝色的图这里 我们已经访问了一些元素 大于主元元素 下一个新元素小于主元元素 这真的是一种很关键的情况 现在一步交换之后我们还需要做的 另一件事就是 现在唯一数组中小于主元元素 和大于主元元素之间的基准已经移动了 向右移动一位 那么我们要"i"加1 这是主要的线性扫描 当它结束时 "j"将会出界 并且我们最终见到的所有元素 除了主元元素 都会按照首先是小于主元元素的部分 最后是大于主元元素的部分这样排序 我们还需要做的最后一步就是 将主元元素交换到正确位置 还记得 我们只需要把它和小于它的 最右元素交换即可 就是这样 这就是Partition子程序 有很多种分割方法 这肯定不是唯一的实现方法 如果你浏览网页或者参考特定的教科书 你会发现一些其他的实现方法 以及对各式优点的讨论 但是我希望这节课能够给予你 我的意思是 这是一种非常经典的实现 我希望它给你一个清晰的思路 如何利用原地交换重新排列数组 以便于得到所需属性 即小于主元元素的部分排在前面 所以大于主元元素的部分排在最后 让我解释一下 为什么我给你们的伪代码 的确有所要求的性质 运行时间是O(N) 实际上是theta N 但是我这里偷懒 写了O(N) N是我们已经访问的数组元素的个数 因此N是r-el+1 即触发Partition子程序的 子数组的长度 为什么这是正确的 如果你去检查伪代码 你可以简单数一下 你就会发现这是正确的 我们只是对数组线性扫描 我们所做的基本上就是一次比较 可能有一次交换 并且给我们访问的元素序号加1 此外 如果你检查代码 很明显这是原地操作 我们没有像在朴素的Partion子程序那样 分配第二个拷贝数组用来填充 我们所做的只是重复交换 归纳法可以证明子程序的正确性 最后的证明方法是通过循环不变量 我会在这里陈述循环不变量 不过基本上都留给你们检查 for循环的每一步迭代的确 都维持了循环不变量 首先所有主元元素右边的元素 即最左元素右边的直到序号"i" 都的确小于主元元素 如图所示 同样如图所示 从"i"开始的所有元素 一直到第"j"个元素之前 都大于主元元素 这个好的练习留给你们 即检查这个论点可由归纳法证明 最开始当"i"和"j"都等于el+1时 循环不变量成立 因为这两个集合都为空 对吧 没有元素 所以他们平凡地都满足这些性质 接着 每次我们向前移动"j" 一种情况很简单 即新元素大于主元元素 显然循环不变量成立 下一个迭代也成立 接着 如果你仔细思考新元素 小于主元元素的情况 交换同时增加"i" 交换之后 如果循环不变量一开始正确 结束的时候也是正确的 那这有什么好处 按照这种说法 在线性扫描结束时 即"j"出界时 数组一定长得这样 for循环结束时 数组的这个问号已经消失了 除了主元元素的所有元素都被安排好 以致于所有小于主元元素的排在 所有大于主元元素部分的前面 这意味着当你做完最后一步交换 当你把第一位也是最左的主元元素 和小于主元元素的最右元素交换 你就做完了 你得到了所需性质 即主元元素左边的所有元素都小于它 右边的都大于它 那么现在已知主元元素 我们理解了如何快速重新排列数组 以便于它围绕主元元素分割 接着我们要理解 如何选取主元元素 以及已知一些合适的主元元素 如何实现快速排序算法的快速运行 尤其是在平均O(nlogn)时间内 翻译: Hongchen | 审阅: Cousera Global Translator Community 
