0:00 在这段视频中，我们要来讨论下如何分析一个算法。 我要以一个非常有名的排序算法来作为开场，这就是“归并排序“ (Merge Sort) 算法。 接着我会精确地告诉你归并排序最多需要多少操作数 来正确地把输入数列排序。 我觉得我得先对各位抱歉： 现在是2012年了，归并排序这个古老的算法看起来已经相当遥远了。 即使回到冯纽曼那个时代――1945年，归并排序也是众所周知的了。 所以，我为什么要在这个现代算法课程中用这么一个古老的算法来作为范例呢？ 这有很多原因： 第一，虽然我们之后会讨论到许多算法，归并排序是很古老，但是它也很好。 归并排序大概已经有六、七十年的历史了，但是我们一直用它来排序，它的确是个很实用的算法， 它也总是被列入很多标准库中，作为标准的排序算法。这就是第一个原因。 当然还有很多其他的原因，我会在后面仔细说明。 首先，在这个网上课程中，我们将看到很多应用于各个领域的通用型算法。 我们先来着重讨论“分治法” (Divide-and-Conquer) 算法设计。 分治法的基本原理是将原本的问题分成几个较小的问题，然后以递归的方法来解决他们， 接着，把这些结果结合起来以解决原本的问题。 归并排序直到今天都也许是最容易理解的分治法算法的一个例子。 它清晰地呈现出这类算法的设计理念、分析中得挑战以及其优点。 说到优点，你们可能已经知道排序是什么意思， 或许也知道一些排序算法，其中可能就有归并排序。 相较于其他简单的或者说是很直觉的排序算法，归并算法更有优势。 例如，你可能已经了解的三种排序算法――选择排序、插入排序、冒泡排序，虽然在这个课程中我们不会讲到它们 如果你还不了解这些排序算法，我希望你能从书上或者网上查一查。 我们来看看这三种看起来比较简单的排序算法。第一个叫做“选择排序”。 你将在输入数列中寻找最小的元素，然后重复这个过程， 所以选择排序的基本原理就是以线性方式来寻找最小值的过程。 接下来是“插入排序”，它虽然没有归并排序那么好，但是在有些情况下来说也是很实用的，我们会在之后谈到。 插入排序的基本原理是将已经排序的元素放在数列前面，并将下一个元素放在对应位置，重复这个过程直至全部排序。 像这样进行十个回合之后，排在最前面的十个元素都是已经排序了的。 当所有的元素都被处理过后，那么整个数列也就排好序了。 最后我们看到的是你也许已经了解的“冒泡排序”了，其基本原理是判断相邻的元素是否正确排列， 如果没有正确排列，就交换这对相邻的元素的位置，重复操作直到整个数列都排好序为止。 再次提醒，这些算法都是比归并算法更简单的排序算法， 但是它们的效率都不怎么高。如果有N个元素需要排序，它们的时间复杂度大约是N^2这个级别。 换句话来说，它们将花费以平方级来计算的执行时间。 然而，如果我们用那些不是很直接或者不是很显而易见的分治法，我们能得到比较快的执行结果。 相较而言，才用分治法是个比较好的作法，而归并排序正式充分应用了这个优点。 第二，归并排序可以为你未来的课程做好定位。 在接下来的讨论中，我想我可以帮助你来判断自己的程度是否适合这个课程。 特别要指出的是，在讲解归并算法时，我不会一行一行地解释程序的运行原理，你需要自己理解并编写。 我假设你是已经有了一定经验的程序设计者，你应该能够理解较抽象的算法， 而且应当能自己将算法的原理加以诠释，并能用你熟悉的程序语言来编写出来。 我不知道用这种方式来分析归并排序对你来说是否会很困难， 但是我希望你终将会发现这反而是相对直接的方式， 毕竟，随着课程深入，后面讲到的算法及其分析都会比归并排序要复杂。 所以，换句话说，我们或许可以用归并排序来做个热身。 第三个原因，是因为分析算法的方式和分析其他事物不太一样。 当我们在分析时，我必须先做几个假设性前提，并且集中分析最差情况， 如果不这么做的话，我们就得必须逐项分析所以输入参数的情形并检验每种情况。 然后采用所谓的“渐进分析法”来观察算法效率的增长率，但是这样一来，我们就无法用低阶因子或者常数来表示。 最后，我们会采用所谓的“递归树”的方法来分析归并排序。 这种方法可以用来计算一种算法总共执行了多少个步骤。 就像我们接下来会看到的那样，这个递归树的方法做得不错， 我们可以用它来分析许多种不太的递归和分治型算法，包括我们之前讲过的两数相乘的方法。 这些就是我用归并排序作为开场的理由。 那么，到底归并排序是用来解决那种计算问题呢？ 好吧，先假设你知道什么叫做排序。但是，让我先阐明几件事，以确保我们的认知没有差别。 现在，假设我们有一个含有N个元素的随机数列作为输入，我们要把它们从小到达进行排序后输出。 例如，我们假设这个是输入数列，我们的目的是把它排列成如下所示的输出数列。 让我注解一下：请注意这个输入数列，它总共有8个元素，每个都是从1到8的不重复的整数。 如果个别数有重复的话，这并不会提高困难度；相反，这样反而会更简单一些。 但是为了简化课程的讨论过程，我还是使用不重复的数值。 至于重复数值是否会让归并排序的分析和结果变得不一样这个问题，我就把它留作给同学们的课后作业吧。 所以为了简化起见，我们还是继续使用不重复的数值来作为这个例子。 在我把归并排序的伪代码写下来之前，我先画这个图来表示该算法的过程。 至于程序的部分，即使我只举出一个例子，我想它也应该很容易地写出来。 现在，我们把上一张中得那串数字来作为未排序的输入数列。 由于归并排序是中递归算法，即把原来的问题分解成几个较小的问题，再递归地交给同一个程序，对吧？ 归并排序的本质就是把输入数列进行排序，它会把输入数列分解，再把分解后的较小数列返回给自己。 这是个典型的分治型应用范例。我们把输入数列分成两半，先递归地解决左半部分，再解决有半部分，接着整合出结果。 现在我们来看看图解。 第一个递归取左半部分4个元素作为输入，也就是5,4,1,8；另一个递归取另外四个元素，也就是7,2,6,3。 你可以想象一下，在把分解后的元素输入给递归之前，它们的数字都已经被复制到新的数列里面了。 借由这个神奇的递归，或许你比较喜欢叫做“归纳原理”，我们只要触发那些递归就能把事情做好。 它们会把这两个含有4个元素的数列进行排序，然后把排序完成后的数列返回。 所以，在第一个递归中，我们得到排好序的输出数列是1,4,5,8；同理，第二个递归中得到2,3,6,7。 要完成整个归并排序，就是把以递归方法得到的两个含有4个元素的数列进行组合，成为最后排好序的8个元素。 因此，我们把上面这个步骤称之为“合并” (Merge)。 我希望你已经在思考如何把这个合并过程以有效的计算机程序来实现。 不过我还有一些细节没有交代，我会在之后明确地讲清楚。 事实上，我们就是照着图中的箭头向下走，把数列分解、复制，再把排好序的结果输出，如此而已。 不过我会再深入地讲解，大概需要1-2张幻灯片。 以上就是我用画图的方式讲解的归并排序―― 把原始数列对半分解、以递归的方式分别解决，再使用某种巧妙的程序 把结果合并以得到最好排好序的输出数列。 