0:00
好的，让我们继续，讨论归并排序的伪代码应该是怎样 首先，我先解释一下什么是伪代码 先不管归并的子程序具体是怎么实现的，假设子程序已经存在 这样，上层的合并就非常简明了。因此，这里会有两个递归调用 然后会有一个合并的步骤。当然，这里我省略了一些细节 因为我有点马虎。不过，就像我之前说的，我不会直接给你 算法程序。尽管也非常接近了。那么我会省略掉哪些东西呢 [这里听不清]首先，在递归算法中 你必须有一个基准。你必须知道 当输入为什么的时候，这个算法就简化到可以停止了 只需要返回一个显然的答案。在排序问题中，这个基准就是 你的数列中只含有0个或1个元素。那么这肯定就是排好序的 你也不能对这个数列再做什么，只需要原样返回就好 好的，我要再明确一下，我不会写下任何基准。但是你们如果想要 让这个归并排序算法可以运行，你们必须在程序中给出，要记住这点。 还有其它一些我在伪代码中不会提及的事，比如如果这个数组的长度为奇数怎么办 如果它有九个元素，那么你就不能把数列平均分成两份 你必须稍作处理，比如一边为5个一边为4个元素 还有，我不会给出你们递归排序的具体细节 比如，我不会去讨论在递归调用中你们究竟要如何 把子数列的值返回给函数。这个主要是 依赖于你们的编程语言。所以 我不会去具体讨论这个问题。我真正想要讨论的是那些 超越于任何编程语言的，抽象出来的算法的概念。 好的，下面来讨论一个算法中较难的部分 你怎么来实现归并的深度？当递归调用做完了它们的工作后 我们有两个已经排好序的子数列。左数列和右数列， 那么我们怎么把这两个数列合并？其实， 上一个幻灯片中，我已经解释过了。思路就是你把输出按序排好 然后用指针去遍历数组，或同时遍历这两个。 我再详细解释一下，这里是归并步骤的伪代码 [一些不明声音]我们先开始介绍 这里一些符号的含义，我们用C 来定义我们的输出数组，也就是我们想要去通过两个排好序的子数组合并得到的。 然后，我用a和b来定义两个递归调用的结果。 第一个递归可以得到a数组 也是输入数组的左半边子数组 b就代表了已经排好序的右半子数组 如之前所说，我们将同时遍历这两个已经排好序的子数组a和  因此，这里需要一个计数器i，来遍历  j来遍历b。i和j的初始值都为1.指向这两个数组的首位 现在我们要做的是，把输出的数值 复制为一个升序的序列。也就是始终把 两个子数组的最小值复制过去。这里你需要想到的 一点是，这个最小元素 一定是在a和b两个子数组的 最开始的位置(除去那些已经写入输出矩阵的元素) 不管是在a数组还是b数组中 整个原始数组的最小值不是在a数组 的头部，就是在b数组的头部。因此你只需要检查这两个位置 然后把较小的数值复制过去 这里的K的目的主要是为了得到输出矩阵当前遍历到的位置。这也是 我们要输出的顺序。再来看一下位置  还有第二个矩阵的位置j。我们现在就得到了， 在两个子数组中已经遍历到的深度。 然后继续比较i和j位置的数值大小，再把较小的复制到C的第k位中 也就是比如a(i)小于b(j)，那我们就把a(i)的元素复制过去 当然，这里要记住把i递增。这样我们就探索完了a数组的第一个数值 同时如果是b(j)中的元素更小，可以用同样的方式进行 这里我不再详细说明了。以免我们过于专注在排序的小细节上而忽略了整个森林 我这里也不会去说明结束条件，因此如果你真的想要 实现这个算法，你必须自己把停止条件加进去。来防止无休止的循环下去 无论对a还是b，你都要去检查i和j是否已经指向了数组的最后 或是判断什么时候你已经把所有的元素都复制到C中了 我会给你一个简洁的伪代码版本 这样你就不用忍受我毫无章法的手写体了 而这也是我们在上一个幻灯片中提过的相同的事情 也就是归并排序的伪代码。好的，这就是归并排序算法 现在，让我们进入这个课题最有趣的部分 归并排序能够获得一个排好序的数组。但是我们为什么会认为它比那些 没有用分治算法思想去排序的方法要好呢？比如，插入排序 换句话说，排序算法的运行时间是多少？现在我会给你一个 准确的定义，就是关于我这里所说的运行时间 稍后会解释，我们这么做是有足够的理论依据的。但是，先从直观上来看 你应该考虑一个算法的运行时间，应该从一个调试者的角度 来考虑算法的运行。每一次你点击运行，然后通过调试器 来一步一步的运行。那么基本上，运行时间就是 你所执行的操作的数量，代码执行过的行数 所以现在的问题就是，你需要点击多少次运行来使程序执行完成 也就是，我们感兴趣的是在归并算法中，当输入数组有n个数字 那么你实际执行的代码行数是多少。当然，这是 一个相当复杂的问题。所以我们先从一个相对简单的方面开始， 先不考虑归并排序实际执行的操作的数量， 不管这个疯狂的递归算法，到底不断重复又重复的调用了它自己多少次 我们先来考虑只是把两个已经排好序的子数组合并 所需要的操作步数。这个任务听起来容易开始多了 我们回忆一下，归并子程序的伪代码 我们现在顺着步骤走，计算这里会用到的 操作步数有多少。这里是初始化步骤。 这两个初始化步骤将各自消耗我们一步操作 因此这里需要2步，来让i=1，j=1.然后我们进入for循环 要知道for循环总共执行的步数，首先需要知道每一步迭代 花费了多少步，这里有一步，然后我们需要比较 A(i)和B(j)，而且每比较完一次，我们就需要做 另两步操作，我们在这或这做一个赋值。然后 要对相关的变量做一个递增。因此每一步迭代将会花费 3步操作。然后还有K递增的步骤，我们可以 把这称为第四步。因此对于这个for循环的N次迭代， 每一次迭代将会执行四次操作。把它们加到一起 我们就得到了这个合并的运行时间。我们再来看一下结果 这个结果是合并的子程序的运行时间，给定一个 M个数字的数组，最多会执行4*M+2步操作。这里先说明两点 首先，我把数组的维度改了，以免你会困惑 上一页PPT中我们一直在考虑输入N个数字的情况。并且我们也讨论完成了 因此这里我把变量名称换成M。这样当我们考虑合并时会更方便 因为程序是递归的在两个更小的问题上进行的。 不过无论是M还是N，都是一样的。总之对于一个M维的输入数组，我们会执行4*M+2次操作 另一件事就是，关于我们刚刚究竟是怎样计算代码行数的还有一些不太清楚 的地方。你可能对循环会有异议，就是 每一次循环迭代应该算做两次操作，而不是一次 因为你不仅仅是递增K，同时还需要 和N对比。所以是5*M+2步而不是4*M+2 因此计算方式的不同会使结果有一些小差异。不过执行的代码行数 具体是多少并没有太大关系，我们之后会说为什么。 我们暂时还是设定，对于M维的数组， 合并所需要的步骤是4M+2.然后，我们可以放大一下 加上一个虽然看起来很草率，但是却绝对正确的不等式 因为，这会让我们接下来的分析容易很多。4M+2中的2 始终让我感觉很不舒服。我们知道M是大于等于1的 所以可以令这个式子小于6M。这个不等式是肯定成立的 虽然显得很马虎。因为当M很大时，这两个式子也会 相差很大。但是这一切都是为了以后的分析简便考虑 好的，我不期望你们现在能够理解这种很粗暴的将 合并子程序执行所需要的步骤上限提升的方式 但要记住我们的最终目的是算出 将输入数组排序所需要的步骤，而不仅仅是这个子程序 事实上，分析归并排序的主程序会更复杂一些 因为它在不停的回调自己本身，而我们需要去分析的这个 递归调用的次数是个呈指数级增长的过程 我们现在还要知道一件事 即每次进行递归调用时，输入数组会不断的减小 每次都是之前的一半大小 因此对于这个问题，一方面是子问题的分裂造成的膨胀， 而另一面又是子问题会越来越小 二者之间形成了牵制 要解决这二者之间的矛盾就要取决于是什么在驱动我们的合并排序分析 我将会完整的分析给你们看 究竟归并排序需要执行的代码行数有多少，并且还可以计算出 一个精确的上界。因此，这里我们可以先给出一个结论，接下来会去证明，结论就是 归并排序总共的步骤不超过 6NlogN+6N 这些就是要把一个N维的数组排序所需要的步数 我们先来讨论一下，这个结果是不是足够好，是不是比其它的方法更优 我们已经知道这个式子是归并排序执行次数的上界，所以答案是肯定的 并且它体现出了分治算法的优势，回顾一下 在一些更简单的排序方法中，比如之前提过的插入排序，选择排序还有 冒泡排序，它们的复杂性是输入数组大小的二次函数 也就是说它们所需要的时间是 N的评分，而归并排序需要的时间 最多为NlogN。 这样你应该能够感觉出来 哪种方式更优，因此，想在这里再次提醒那些 仍然对算法心生恐惧或是感觉无从入手的学生，到底什么是算法。 你应该从以下的角度去考虑算法，比如你有一个X轴 这上面有N个点，从1到无穷 为了方便比较，我们只考虑恒等函数 比如函数是F(n)=n，然后让我们把算法跟它来对比 那么什么是算法，在这里，我们可以这么来看， 以2为底的logn，就是你在你的计算器中输入N，然后你令它除2，然后 不停的重复这个过程 然后你可以 数一下需要重复多少次这个过程，最终才可以得到 一个小于一的数。比如对于32，你需要除5次 来得到小于等于1的数。因此log32是5.输入1024 你需要除2除10次，那么log1024等于10，等等 那么对于1000呢，通过上面的例子，你应该能够看出来 也差不多需要除10次。所以这个算法需要的输入比起原始的N已经小很多很多了 从图形上，这个算法会是长这个样子， 首先会是一条曲线，然后随着N的增大迅速的变平。这个新的F(n)就是 以2为底的logn。我希望你们有时候也可以画一下 可以通过电脑或是一些图形软件画的更精确一点 但是对数函数运行起来会比恒等函数慢很多，因此 总之结果就是，一个运行时间近似于nlogn的倍数的排序算法 比起那些运行时间近似于n的平方的倍数的排序算法 要快很多。尤其是n很大的时候 
