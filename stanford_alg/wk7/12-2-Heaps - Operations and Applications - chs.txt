0:00
在这节课中 我们会开始学习堆 我想要把几件事情讲清楚 堆都支持什么操作 通过经典的时间上界分析保证多短的期望运行时间 我想让你们对什么样的问题适合使用堆有一定感觉 在另外的一个视频里 我们会掀开堆结构神秘的面纱 简单了解一下它是如何实现的 但现在我们需要集中讨论 如何直接使用它们 对于一个数据结构你要记住的第一件事 是它都支持什么操作和这些操作的期望运行时间 根本来讲 堆支持两种操作 你还可以给它附加一些操作 但是必须知道的两个操作是插入和取出最小值 关于堆我要说的第一件事是它是一个容纳一堆对象的容器 每一个对象都应该有一个关键值 比如一个数 所以你可以比较任意对象的关键值 说明一个关键值比另一个大 比如对象可以是雇员信息 那个关键值就是社保号 或许对象是网络的边 关键值就是边的长度或者权值 或许每个对象是一件事 关键值就是它应该发生的时间点 关于数据结构你应该记住的头等大事是 第一 它都支持什么操作 第二 这些操作的期望运行时间是什么 堆有最基本的两种操作 插入和取出关键值最小的对象 所以在我们讨论堆的过程中 我们允许有相等的关键值 但有没有相等的关键值都一样简单 所以当你提取最小值时 也许会有重复的关键值 那么你提取哪个并没有严格规定 你只是从含并列最小关键值的对象中提取出一个 当然 我提取最小值而不是最大值也没有特殊的原因 你既可以有一个最大值堆的概念 这个最大堆总是返回含最大关键值的对象 或者组织一个类似于最小堆的堆 在插入关键值的时候取相反数 这样提取最小值的操作提取的其实就是最大值 但清晰起见 我没在建议你建立一个同时支持提取最小值最大值的堆 如果你这两种操作都想要 有其他数据结构提供这种操作 你最先考虑的基本应该是二叉搜索树 所以我只是在说 你的堆可以有两种操作中的一种 这个堆要么支持提取最小值不支持提取最大值 要么支持提取最大值不支持提取最小值 我还提到了你们不应该只在意一个数据结构支持的操作 还应该注意这些操作的运行时间 对于一个用经典方法实现的堆 期望时间是对象总数的对数级别的 底数是2 常数很小 所以你考虑到堆的时候 一定要记住这两种操作 堆还有一些其他值得记住的性质可供选择 就是它可以支持的一些附加操作 第一个叫作堆化 像有关堆的一些其他内容 堆化有好几个名称 不过我就叫它堆化 标准名称之一 堆化的目的是在线性时间内初始化一个堆 如果你有N个对象想要放到堆里 很显然你可以对每个对象执行一次插入 如果你有N个对象 看起来大概需要O(NlogN)的时间 每个N用O(logN)时间插入 但是有一种巧妙的方法 可以在线性时间内一次性插入所有元素 这就是堆化 还有一种尽管有些小麻烦 还是可以实现的操作 就是你可以删除的不仅是最小值 还有堆中任何元素 耗时线性时间 我在这里提它是因为我们在用堆优化Dijkstra算法时 会用到这个操作 这就是堆的要点 你组织维护带关键值的元素 可以在对数时间内插入 以及查找具有最小关键值的元素 我们来看看应用 我已经举了几个例子 但我在详细介绍一个应用之前再强调一下 基本原则是什么? 什么会让你在处理某些任务的时候 考虑使用堆? 最普遍的原因就是你注意到了 你的程序在一遍一遍地寻找最小值 尤其是用暴力搜索求最小值的时候 我们要了解的好多堆应用 都有这个特点 就是它们有一个用暴力搜索 求了好多最小值的朴素程序 而简单地应用堆就可以极大地优化它们 我们从所有计算问题之母 排序 讲起 有一个特别好想的次优排序算法 我根本没在课程里费心提到 就是选择排序 在选择排序中 你彻底扫描未排序的数组 找到最小元素 把它放在第一位 你再扫描剩下的N-1个元素 再找到其中的最小值 把它放在第二个位置 你再扫描剩下的N-2个元素 找到最小值 放到第三个位置 一遍一遍这么做 很显然 这个次优的排序算法在数组中 执行了线性次数的线性扫描 它绝对是O(N^2)级别的 这就是我之前没有给你们讲它的原因 所以显然 这个算法符合了那个重复执行最小值搜索的特点 每次运算 我们都在彻底暴力搜索 所以我们的智慧明灯就要点亮了 我们可以用一个堆结构来优化吗? 答案是肯定的 随之而来的排序算法叫作堆排序 有了堆结构 这个算法就很简单了 我们只需要从数列中 把所有元素插入到堆 然后一个一个地提取最小值 第一次 我们提取到了所有N个元素中的最小值 第二次就是剩下N-1个元素中的最小值 以此类推 我们这样一个一个提取最小值 就可以从左到右填满有序数列 排序结束了那么运行时间是多少呢? 对于每个元素执行一次插入一次提取 总共2N个堆操作 我向你们保证过堆的实现可以达到每个操作只消耗对数时间 所以我们执行了线性次数的对数时间操作 运行时间O(N log N) 我们可以后退一步看看刚刚发生的事 我们拿来最没有新意的排序算法 平方时间的选择排序 我们意识到了它重复地计算最小值 我们运用了堆数据结构 哇 我们就得到了一个只含两个过程的N logN时间的排序算法 要记住 对于排序 N logN已经是很好的运行时间了 它恰好是我们归并排序的运行时间 随机化快速排序的平均运行时间 不仅如此 堆排序是一个基于比较的排序算法 我们没有任何有关元素的其他数据 只有一个完全打乱的数组 而且你们有人应该看了那个自选视频 不存在一个比N logN还快的基于比较的排序算法 所以对于那个"我们能做的更好吗?"的问题 如果我们用一个类似于堆排序基于比较的排序算法 答案是不能 这是非常精彩的 我们只是用了堆结构 运行时间就从不怎么样的平方级别 降到了最优的N logN级别 不仅如此 堆排序相当有应用价值 它运行速度真的很快 不过它有快速排序好吗? 也许没有 不过差不多 它们是同一级别的了 我们来讨论一下另一个从某种角度来讲比较偏的应用 但它也是堆的经典应用 在这里 大家会自然地将堆叫作优先队列 来思考一下 你有一个任务 要写软件模拟现实世界 假设你在写一个篮球的电子游戏 为什么堆可以被用在模拟中? 这个应用的对象将会是事件记录 比如一个事件可以是球会在某个特定的事件到达球筐 原因是几秒钟之前一个运动员投了篮 如果球打到篮圈 近期内就会有另外一个事件 几个运动员抢篮板球 这可以引发另外一个事件 就是其中一个运动员拉人犯规 把另一个运动员拉倒在了地上 这就可以引发另外一个事件 所以当你处理这样的事件记录的时候时候 有一个很自然的关键值 就是时间戳 一件事在未来将会发生的事件 你在这种模拟中需要一遍又一遍解决的一个问题就是 确定下一个发生的事件是什么 你才能确定其他的事件 更新屏幕信息 诸如此类 这就是一个最小值运算 比较傻的做法就是维持一个无序的事件列表 然后线性地扫描 寻找最小值 这样你就会一遍又一遍寻找最小值 智慧灯泡又要亮起来了 你会想到 堆也许正好满足问题的需要 确实是这样 所以如果你在堆中储存这些事件记录 关键值是时间戳 你就有了一个提取事件的超级武器 在对数时间内决定 下一个发生的事件是什么 我们再来看看一个不是那么好想的堆应用 我把它叫作中位数维护 它工作的方式就是 我和你在玩一场游戏 我要做的事是给你递索引卡片 每一张上写着一个数字 你要告诉我 每一次结束后我已经递给你的数字的中位数 所以在我给你前11个数字之后 你要尽快告诉我 第六小的数字 我给你十三个之后 你应该告诉我第七小的数字 以此类推 我们知道如何在线性时间内计算中位数 但是我不想让你们每一步都消耗线性时间计算中位数 当我只给你新增一个数字时 你真的需要花费线性时间 只为重新计算中位数吗? 所以为了确保不是每一次我给你新数字你都线性选择中位数 我会给你每一步可以用的时间定一个上界 这个时间上界是已经有的数字个数的对数 我希望你们在这里暂停视频 思考一下你将如何解决这个问题 好 希望你们已经有了一些想法 我来给一个暗示 如果用两个堆结构 你能想出来一种解决问题的好方法吗? 让我来给你们讲一下解决方案 这个方案用到了两个堆 第一个叫作H低 这个堆支持提取最大值 回忆一下 我们讲堆的时候 提到了一个堆可以支持提取最小值或最大值 虽然不能支持 但可以二选一 我们还有一个H高 支持提取最小值 核心思想就是 你收到的数字中较小的一半在H低中 较大的一半 则在H高中 比如 当你收到了前十个数字 较小的五个被储存在H低中 较大的五个被储存在H高中 如果你已经收到了20个数字 较小的十个应该在H低中 较大的十个应该在H高中 数字总数是计数 H高H低哪个大一些都行 没什么影响 所以如果你有21个数字 你可以将较小的十个放在H低中 较大的十个放在H高中 反之亦然 这不重要 当你有了这个利用堆对半分开数字的想法 你还需要意识到两点 我会让你们自己证明 第一 你需要 你可以在第i步中用O(log i)的时间保持循环不变式 第二 你要证明这个循环不变式可以帮助你解决问题 我来简单地讲一些这两点 你可以利用自己的时间深入思考 第一 我们如何在第i步只进行log i次基本操作 维持循环不变式呢? 这个方法有点狡猾 假设我们已经处理了前20个数字 已经努力地 把较小的十个放在了H低中 把较大的十个放在了H高中 现在有一个初步的结果 关于H低中的最大值 我们知道些什么呢? H低中的元素是全体元素中最小的十个 其中的最大值 就是最小的十个中的最大 是H低中的第10项数据 也是 全体元素中的第十项 那么H高呢? 它的最小值是什么? H高中包含了最大的十个值 所以它们中的最小值就是 第11项数据 所以H低中的最大值是第10项 H高中的最小值是第11项 这两个元素相邻 它们就是全体元素的两个中位数 所以当第21个元素被输入的时候 我们需要知道 把它放在哪个堆里 很简单 如果它比第十项小 它就属于较小的那一半 需要放在H低中 如果它比第11项大 就是比H高中的最小值大 那它就是H高中的一员 如果它介于第10和11项之间 这就没关系了 把它放在哪个堆里都可以 反正它是新的中位数 但是这个第一点还没结束 因为会有潜在的不平衡 假设第21个元素被输入了 它比H低中的最大值小 所以我们把它放到H低 H低现在有了11个元素 第22个元素输入了之后 又比H低中的最大值小 我们又把它放在了H低中 现在H低中有了12个元素 但是在H高中只有10个元素 元素的分布不是半对半的 但是我们可以轻松地重新平衡元素分配 只要将H低中的最大值放到H高中即可 这样它们就都有了11个元素 H低中的是前11个 H高中的是后11个 所以这就是你维持半对半分开较小和较大元素的循环不变式 的方法 你来证明两件事 第一 只要将新元素和H低的最大值和H高的最小值比较 你就能把它放到合适位置 第二 每次你需要平衡两个堆时 你都这样做了 现在 当每输入一个新数字的时候 这个算法只需要常数个堆操作 所以执行log i的基本操作 在以上讲解的基础上 只要循环不变式不变 时间一定是log i的 那么我们如何计算中位数? 它是H低最大值和H高最小值中的一个 当中的一个(或两个) 取决于i的奇偶性 如果是偶数 两个都是中位数 如果是奇数 比另一个堆多一个元素的堆的最值就是 堆的最后一个应用 我会在另一个视频中详细讲解 那个视频细致分析了 Dijkstra算法运行时间 我在这里简单提一下 也是为了重申 良好的数据结构运用可以多么明显地优化算法 尤其是你在内层循环中做类似于求最小值的操作时 关于Dijkstra算法 希望你们大多数都已经看了那个视频 基本来说 这个算法有一个核心外层循环 它对图中每一个结点运行一次 如果我们简单地看 外层循环每次运行都对图中的边进行了彻底搜索 来计算最小值 所以如果我们分析这种朴素实现的算法中的操作 这就是堆的用武之地 因为在每个外层循环中 我们都进行彻底搜索 求最小值 你们发现重复计算最小值的情况 智慧灯泡就要点亮了 想到堆或许可以很有用 在Dijkstra算法中堆确实很有用 细节有些复杂 我会在另外一个视频里讲 但最终的结果就是 我们在运行时间上得到了很大的优化 令m代表边的数量 n代表结点的数量 当我们谨慎地在Dijkstra算法中使用堆的时候 运行时间从这个大多项式 结点数量和边数量的乘积 降到了几乎线性的程度 O(m log n) m是边的数量 n是结点数量 这个线性时间就是O(m) 我们还有一个对数级别的因子 但这个时间已经和排序一样好了 所以这是个快的惊人的最短路算法 比你们不用堆而是简单重复求最小值的算法强得多 以下就是对我希望你们了解的堆的知识的总结 它支持的核心操作是什么? 这些操作的期望运行时间是多少? 这个数据结构会优化 什么种类的算法? 以及一系列应用 对于那些想要达到更高级别 了解一些实现内情的人 有一个专门的视频 涉及到了那部分的知识 
