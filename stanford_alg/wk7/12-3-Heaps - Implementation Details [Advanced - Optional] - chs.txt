0:00
在这节课中 我们会至少简单接触到堆结构的下一层次知识 即 我们会讲解一些实现的细节 比如 如何从零开始编写堆数据结构? 回忆一下堆的要点 它是一个容纳对象的容器 每一个对象和可能附加的好多其他数据 都应有一个关键值 我们要能做到比较不同对象的关键值 你知道的比如不同雇员的社保号码 网络中不同边的权重 不同时间的时间戳 诸如此类 记住 对于任何数据结构 你应该知道的头等大事是 它都支持什么操作 还有比如这个结构适合干什么 还有这些操作的期望运行时间 我之前保证过 我会讲堆两种基本操作的实现方法 第一 你可以向堆中插入对象 这个操作消耗堆中对象个数的对数级别的时间 第二 可以提取关键值最小的对象 我们允许堆中有重复的对象 所以如果有重复的 我就有一个并列最小值 堆会返回并列对象中的一个 不一定是哪一个 我早些也提到过 你们可以给堆添加其他的操作 比如成批插入对象 不过这消耗线性时间 而不是对数时间 你可以从堆中间删除元素 我不会在这里讲这些 我只会着重介绍如何插入和提取最小值 如果你真的想知道堆是如何运行的 要时刻把堆看成两种结构 一棵树和一个数组 在这页幻灯片上我们从树的角度开始讲 理论上 这对于解释堆操作是如何实现的很有帮助 理论上 我们不把堆看成一棵任意的树 而是一棵有根二叉树 这就意味着每个结点有0 1或2个孩子结点 还有 这棵树是尽可能完全的 我来画一棵有九个结点 尽可能完全的二叉树 博大家一笑 如果这棵树只有七个结点 很显然它是完全完全的 这就意味着我们只能完全填满三层 如果有15个结点 我们就完全填满了四层 但是在7到15 这两个2^n-1的数之间 我们把一棵叶子层从左到右填充的树看成完全树 所以这棵树在第四层有两个多余的叶子 它们俩都是尽可能靠左的 这就是我们在脑海中 直观想象堆的方式 接下来我来定义一下堆性质 这个性质维持了不同对象在这个树里面的一个顺序 堆性质表明 对于这棵树中的每一个结点 不管是根结点 叶子结点还是中间的任意一个结点 对于每一个结点X X的关键值不大于X的孩子的关键值 如果X是一个叶子结点 它没有孩子 它也有可能有两个孩子 不管是什么情况 这0 1或2个孩子 的关键值大于等于X的关键值 这有一个七结点的堆 注意 我允许堆中有重复 这有三个关键值为4的对象 还要注意到 尽管堆性质提供了堆中的对象排列方法 它并没有确定下来某一个排列 所以这套完全一样的七个结点可以有别的排列方式 它们仍然是一个堆 重点是 在任意一个堆中 根结点关键值一定最小 就像这七个结点排列的这两种方式 根结点永远是4 最小值 考虑到我们想要快速实现的基本操作中的一个 提取最小值 这是件好事 至少我们知道最小值在哪了 它一定在堆的根结点上 但虽然我们在脑海中将堆想成树 我们不直接把它实现成树 在类似于搜索树的结构中 每个结点真的包含指针 你可以反转指针 从父母到孩子 从孩子到父母 诸如此类 但实际上对于堆 直接用数组实现更为高效 让我用上一页的例子讲解一下 我们怎么用数组表示一个树状结构 让我们来分析一个大一点的堆 有九个对象 我来画一个有九个位置的数组 从1一直标到9 我们将脑海中的树映射到这个数组中的方法非常自然 我们只要按层数将数中的结点分组 根结点是第0层中的唯一一个结点 根结点的孩子是第一层 它们的孩子是第二层的 我们的第三层没有填满 只有最后两个结点 然后只要把这些结点粘贴到数组里即可 根结点在 至高无上的第一个位置里 它就是数组中的第一个 这个是第一个4 然后我们放入第一层的对象 就是第二个4和那个8 然后我们放入第二层的对象 里面有第三个4和两个9 然后我们放入第三层中的最后两个结点 占据了数组的倒数第二和倒数第一个位置 你可能在想 这就像我们拿来蛋糕直接吃了 这边我们有一个充满逻辑的漂亮的树结构 这边我们用数组实现 没有浪费通常树结构实现包含的指针空间 就是用来连接父亲和孩子的指针 免费的午餐从哪来的呢? 原因就是我们可以让这个树尽可能平衡 不需要指针来判断谁是谁的父亲或孩子 我们可以直接从数组的位置中获得相关信息 我来说的详细一点 如果第i个位置上有一个元素 假设i不等于1 根结点没有父亲结点 但是其他的第i个结点有父亲结点 那个父亲结点的位置只取决于i的奇偶性 如果i是偶数 父亲结点就是在i/2位置上 如果i是奇数 还是i/2 那是一个分数 我们只要向下取整就 举个例子 第2和第3个位置上的对象的父亲结点 都在第1位置 第4和第5位置上结点的父亲结点 在第2位置 第6和第7位置上结点的父亲结点 在第3位置 以此类推 我们把求父亲结点的函数反过来 就可以轻易地推出已知结点的孩子结点 如果我们在第i个位置上有一个对象 它的孩子 就在第2*i和第2*i+1位置上 这些位置可能是空的 如果i是叶子 它当然没有孩子 也有可能i只有一个孩子 但是在一半情况下 树内部的结点都会有两个孩子 在2*i和2*i+1位置上 比起利用指针 计算一下位置来从孩子到父亲或者从父亲到孩子结点 要简单的多 所以这页幻灯片展示了堆如此常用的一些底层原因 第一 从存储空间来讲 我们根本不需要多余的空间 我们只是将这些对象直接存到了一个数组里 不用多余空间 第二 我们不仅不需要指针的空间 甚至不需要任何的遍历 我们做的事情很简单 只是乘以2或者用2除的操作 用上移位的小把戏 这种操作可以被极快地实现 所以我会在下两页幻灯片中 从更高层次上讲解你将如何实现堆的两种 就是在堆大小的对数时间内进行插入和提取最小值 我不会给你看伪代码 我只会举例讲解这些操作是如何工作的 我觉得将例子推广到一般情况会非常简单 我觉得你完全可以以这里的讲解为基础编写出自己的堆 你自己的插入和提取最小值操作 如果你想的话 我们来重新画一下之前的那个九结点堆 我还会把它画成一个树 我也会在树上讲解 但是一定要记住 真正实现的时候用的是数组 当我提到一个结点的父亲结点的时候 你要根据这个结点的位置号转到那个合适的结点 我们假设已经有了一个堆 就像这个蓝色的一样 我们要插入一个新的对象 关键值是K 记住堆总应该是平衡二叉树 所以如果我们想要 维持堆的平衡性质 只有一个位置可以放置新的K 就是下一个叶子 最底层的新的最右面的叶子 从数组角度来谈 我们只要把它放在 第一个非空的位置 如果我们跟踪了数组的大小 这个操作消耗常数时间 因为我们知道把新关键值放在哪 我们能不能以常数时间结束取决于K的值 作为一个开始 如果我们新的关键值是7 那这个插入就结束了 因为我们没有违反堆性质 每个结点的关键值都不大于它孩子的关键值 具体来讲 这第3个4有了一个新的孩子 但是孩子的关键值7比4大 所以你可能在想 我们或许在下一次插入的时候也很走运 比如下一个关键值是10 我们把它放在最后一层的下一个位置 10成为了 第三个4的第二个孩子 我们又一次没有违反堆性质 这仍然是一个堆 在这些幸运的情况中 每次插入都消耗常数时间 我们就是在数组的最后加一个元素 没有做任何重排 比较有趣的是直接插入违反堆性质的情况 假设我们又插入了一次 插入到12的左孩子 这个新关键值是5 现在问题来了 这个二叉树仍然是尽可能平衡的 但是关键值大小的性质 没有满足 具体来说 在12这个结点这里 它有一个孩子 孩子的结点比它自己的结点小 这不好 所以我们有没有方法维持堆性质呢? 一个自然的想法就是 将5和12的位置换一下 这当然可以在常数时间内完成 因为对于一个结点 我们可以在常数时间内 用一点点小运算交换孩子和父亲结点 所以我们刚开始把5放在数组最后 这不对 我们把5和12换一下 但是我们还没走出困境 12那里没有违反堆性质 这被更正过来了 12现在是叶子 但是我们把违反堆性质的地方上推了 现在问题在8那 8之前有两个孩子 关键值分别是12和9 这没问题 现在8的两个孩子关键值是5和9 5比8小 这违反了堆性质 但是这是唯一 违反堆性质的地方 其他的结点都没问题 因为我们只搞乱了8的孩子 所以我们再来试试交换 交换5和8来在那里修复问题 我们现在已经恢复了顺序 现在唯一有可能违反堆性质的地方是根结点 当我们做这次交换的时候 影响到的唯一一个结点是根结点4 幸运的是 这个新孩子的关键值是5 比根结点大 你可能在思考的一个小问题是 除了通过交换根结点的孩子影响到根结点以外 我们还可能影响到它的兄弟 因为我们换掉了它的父亲 所以这个父亲原来是5 现在是8 所以有没有可能这个父亲的关键值就突然比兄弟大了呢 但如果你思考一下 这个8和12 它们在原堆中是父子关系 所以回到这个蓝色堆中来 12在8下面 现在12又在8下面了 这对结点之前遵守了堆性质 现在还是遵守堆性质的 所以大体来讲 当你把这个5在树中向上推的时候 只有一条边可能会出现问题 这条边就是现在的5和它的父亲之间的那条边 所以当5的父亲是12的时候 违反了堆性质 当5的父亲是8的时候 违反了堆性质 现在我们把5推上来了 父亲是4 比5小 这不违反堆性质 所以大体来讲 插入的第二步就是交换 有很多不同的名字 我将这种操作叫作向上冒泡 因为我多年前学的时候 是这么叫的 我还是承认把 不过有时候也叫作向上筛选 天天向上 之类的 所以我在告诉你 实现插入 只要在堆结构里一直向上冒泡即可 它真的是这么工作的 我把一切都告诉你了 但是你知道 我不打算讲细节 但如果你有兴趣 我鼓励你利用自己的时间探究细节 你主要要注意两件事 第一 冒泡在该停下的时候要停下 它停下的时候堆性质已经恢复了 第二 我觉得很简单就能看出来这个操作消耗的是 堆中结点个数的对数时间 可以观察到这点是因为 它是一棵完全平衡的二叉树 我们清楚地知道有多少层 所以基本就有log2(n)层 n是堆中元素个数 鉴于你只在每层做一些交换和比较等常数时间操作 在最坏情况下每一层都要进行交换 层数是对数级的 这个插入的运行时间就是对数级的 这就是插入 下面我们来讲一下如何实现提取最小值操作 还是举例讲解 还会用到重复的冒泡 所以提取最小值要做到的是从堆中提取一个 具有最小关键值的对象 装在银盘子里送给调用者 所以这只是抹掉根结点 记住最小值一定在根结点 所以这就是我们提取最小值的方式 把根结点提取出来交给调用者 所以这种提取就在我们的树结构中留下了一个空位 这不好 维持堆性质要做的一件事就是 我们的二叉树一定是要尽可能平衡的 如果缺了根结点 它当然不是尽可能平衡的二叉树 所以我们要怎么做呢? 如何填补这个空位? 实际上只有一个结点 可以在填补这个空位的同时不给树结构带来其他问题 就是最后一个结点 所以底层的的最右面一个叶子 只要将它和原来的根结点换一下就好了 在这种情况下 13被抬升了很多 直接成了这棵树的新根节点 所以我们解决了这个结构的挑战 我们又拥有了一个尽可能平衡的二叉树 但很明显 我们完全毁掉了堆性质 所以堆性质声明 对于包括根结点的每一个结点 这个结点的关键值要比两个孩子的关键值都小 现在全都乱了 根节点的关键值比两个孩子都大 情况比插入要复杂一些 当我们在堆底插入的时候 每个结点都只有一个父亲结点 如果你想让一个结点在树里上升 它只能去一个位置 所以你只能让它和它的父亲结点交换位置 除非你真的想做一些疯狂的事 但如果你想小规模的处理问题 只有一个父亲结点可以供你交换 现在你想让结点 在树里下降到一个正确的位置 有两种交换可供选择 一个是和左孩子 一个是和右孩子 这个选择很重要 为了更确切地理解这里 我们看这个例子 13在根结点 完全不是它应该在的位置 两个孩子一个是4一个是8 我们可以分别试试让它们和13交换 假设我们错误地让13和右孩子8交换 右孩子现在变成了根结点 13下降了一层 从一个角度上来讲 我们进步了一点 至少在13和8之间 没有违反堆性质 从另一个角度讲 13还是违反了堆性质 13 和12,9之间还是违反了堆性质 不仅如此 我们在8和4之间创造了一个新的问题 所以8现在是根结点 它比左孩子4大 所以我们将13和8交换的时候显然没有任何改进 所以这不是什么好主意 仔细想下就会发现 愚蠢的做法就是将父亲和较大的孩子 交换 这完全没有道理 我们需要将父亲和小孩子交换 记住 每一个结点的关键值都要比它的两个孩子小 所以如果我把4和8中的一个换上去 其中的一个 会变成另一个的父亲 父亲应该比孩子小 显然我们应该选择两个孩子中较小的那个 把它和13交换 所以我们应该将13和4交换 而不是8 现在我们注意到了和插入非常相似的一个现象 当我们在插入中向上冒泡的时候 我们没有 马上完全修复堆性质 我们修复了一个地方 但是导致了树更高处另一个问题 但我们确信 我们可以将问题推到根结点 消灭它 就像试图在打地鼠游戏中获胜 在这里 情况完全相反 我们将13和4交换 确实导致了一个新的违反堆性质的情况 涉及到13和它的孩子 9和4 但是我们没有创造新的问题 我们将堆性质的违反在树中向下推了 仍然很像打地鼠 我们在堆底解决问题 所以在交换了13和4之后 我们要继续做同样的交换 任务还没有结束 这仍然不是一个堆 13比它的两个孩子都大 但是用我们积累来的智慧 我们知道我们应该让13和4交换 而不是和那个9交换 这是当然的 所以我们将4上移到了这里 13占据了4的老位置 成功了 所以现在没有违反堆性质的情况了 13在它的新位置没有孩子 所以不会违反堆性质 而4之前是较小的孩子 比9小 所以我们没有创造新问题 现在堆里有连续的4 但这不是问题 因为它们也是原来的堆里连续的4 所以听到通过将结点和小孩子交换向下移动结点的操作 叫作向下冒泡 你一定不会惊讶 提取最小值也就是将最后一个叶子提到堆顶 让它向下冒泡直到恢复堆性质 理论上讲 这就是从零开始实现堆中提取最小值操作 需要的全部知识 像之前一样 我会让你自己探索细节 第一 你需要确保向下冒泡在某一步会停止 当它停止的时候 你有了一个完美的堆 堆性质全部恢复了 第二 运行时间是对数级别的 这里的运行时间分析 和之前的完全一样 我们已经注意到 因为堆是完全平衡的 所以它的告诉基本就是log 2底 堆中的对象个数 在向下冒泡的时候 你在每层的操作 消耗的都是常数个基本操作 仅仅是一些比较和交换 所以这就是向堆结构面纱下的一瞥 一点堆结构实现的幕后故事 在看完这节课之后 我希望你们感受到了更多程序员和计算机科学家的核心硬件思想 翻译: 张梓愉|审阅: Global Translator Community 
