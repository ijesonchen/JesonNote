WEBVTT

1
00:00:01.013 --> 00:00:06.020
Welcome. I'm Bob Sedgewick, professor of
computer science at Princeton. This is our

2
00:00:06.020 --> 00:00:11.014
online course Algorithms developed by
myself and Kevin Wayne here at Princeton.

3
00:00:11.014 --> 00:00:16.002
We're gonna start with an overview
discussion of why you might want to study

4
00:00:16.002 --> 00:00:21.005
algorithms and a little bit of discussion
about the resources that you need to take

5
00:00:21.005 --> 00:00:26.543
this course. So, what is this course? It's
an intermediate level survey course on

6
00:00:26.543 --> 00:00:31.062
algorithms. We're going to concentrate on
programming and problem solving in the

7
00:00:31.062 --> 00:00:35.870
context of real applications, and our
focus is going to be on two things,

8
00:00:35.870 --> 00:00:41.756
Algorithms which are methods for solving
problems and data structures which store

9
00:00:41.756 --> 00:00:46.651
the information associated in problem,
with a problem and go hand in hand with

10
00:00:46.651 --> 00:00:51.600
algorithms. These are the basic topics
that we'll cover in part one and part two

11
00:00:51.600 --> 00:00:56.559
of the course. The first part is data type
sorting and searching. We'll consider a

12
00:00:56.559 --> 00:01:00.810
number of data structures and algorithms
that are basic to all the methods we

13
00:01:00.810 --> 00:01:05.811
consider including stacks, queues, bags
and priority queues. Then we'll consider

14
00:01:05.811 --> 00:01:09.852
classic algorithms for sorting, putting
things in order. That's quicksort,

15
00:01:09.852 --> 00:01:15.130
mergesort, heapsort and radix sorts. And
we'll consider classic methods for

16
00:01:15.130 --> 00:01:19.932
searching. Including binary search trees,
red-black binary search trees and hash

17
00:01:19.932 --> 00:01:25.166
tables. The second part of the course is
for more advanced algorithms including

18
00:01:25.166 --> 00:01:30.425
graph algorithms, classic graph searching
algorithms, minimum spanning tree and

19
00:01:30.425 --> 00:01:35.417
shortest path algorithms, algorithms for
processing strings including regular

20
00:01:35.417 --> 00:01:41.178
expressions and data compression. And then
some advanced algorithms that make use of

21
00:01:41.178 --> 00:01:46.890
the basic algorithms that we developed
earlier in the course. So, why should one

22
00:01:46.890 --> 00:01:52.075
study algorithms? Well, their input,
impact is very broad and far-reaching.

23
00:01:52.075 --> 00:01:57.185
From the internet to biology to,
commercial computing, computer graphics,

24
00:01:57.185 --> 00:02:02.512
security, multimedia, social networks, and
scientific applications, algorithms are

25
00:02:02.512 --> 00:02:07.805
all around us. They're used for movies and
video games, for particle collision

26
00:02:07.805 --> 00:02:12.910
simulation, they're used to study the
genome, and all manner of other

27
00:02:12.910 --> 00:02:18.319
applications. So, that's one important
reason to study algorithms, their impact

28
00:02:18.319 --> 00:02:23.329
is broad and far-reaching. Algorithms are
also interesting to study, because they,

29
00:02:23.329 --> 00:02:28.064
they have ancient roots. Now the first
algorithm we studied goes back to 300

30
00:02:28.064 --> 00:02:32.588
B.C., dating at least to Euclid. The
concept of an algorithm was formalized

31
00:02:32.588 --> 00:02:37.651
actually here at Princeton, by Church and
Turing, in the 1930s. But most algorithms

32
00:02:37.651 --> 00:02:41.806
that we consider, were discovered in
recent decades. In fact, some were

33
00:02:41.806 --> 00:02:46.452
discovered by undergraduates in a course,
course like this. And there's plenty of

34
00:02:46.452 --> 00:02:51.595
other algorithms waiting to be discovered
by students like you. The main reason that

35
00:02:51.595 --> 00:02:57.239
people study algorithms, is to be able to
solve problems that it could not otherwise

36
00:02:57.239 --> 00:03:02.498
be addressed. For example, in the first
lecture, we're going to talk about the

37
00:03:02.498 --> 00:03:07.234
network connectivity problem, where the
problem is, given a large set of items

38
00:03:07.234 --> 00:03:12.135
that are connected together pairwise is
there a way to get from one to another

39
00:03:12.135 --> 00:03:17.134
with a path through the connections. As
you can see from this example, it's not

40
00:03:17.134 --> 00:03:22.282
clear whether or not there's such a path,
we need a computer program to do it, in

41
00:03:22.282 --> 00:03:28.793
fact, we need an efficient algorithm to do
it. In this case the answer is that there

42
00:03:28.793 --> 00:03:34.241
is such a path. Another reason to study
algorithms is for intellectual

43
00:03:34.241 --> 00:03:39.795
stimulation. Algorithms are very
interesting objects to study. Don Knuth

44
00:03:39.795 --> 00:03:45.275
who wrote several books on, on algorithms
and was a pioneer in the field said that,

45
00:03:45.275 --> 00:03:50.553
"An algorithm must be seen to be
believed." You can't just think about an

46
00:03:50.553 --> 00:03:55.998
algorithm you have to work with it.
Another quote from Francis Sullivan, says,

47
00:03:55.998 --> 00:04:01.412
"The great algorithms are the poetry of
computation." Just like verse, they can be

48
00:04:01.412 --> 00:04:05.905
terse, elusive, dense, and even
mysterious. But once unlocked, they cast a

49
00:04:05.905 --> 00:04:11.473
brilliant new light on some aspect of
computing. Algorithms are interesting for

50
00:04:11.473 --> 00:04:17.057
intellectual stimulation. Another reason
many people study algorithms and I suspect

51
00:04:17.057 --> 00:04:21.565
many of you, is it's necessary to
understand good algorithms, efficient

52
00:04:21.565 --> 00:04:26.760
algorithms, a good data structures in
order to be a proficient programmer. Linus

53
00:04:26.760 --> 00:04:31.358
Torvalds, who created lin, Linux, says
that the difference between a bad

54
00:04:31.358 --> 00:04:36.708
programmer and a good one is whether he
considers his code or his data structures

55
00:04:36.708 --> 00:04:41.739
more important. Bad programmers worry
about the code, good programmers worry

56
00:04:41.739 --> 00:04:45.943
about data structures, and their
relationships. And, I might add, the

57
00:04:45.943 --> 00:04:50.048
algorithms that process them. Niklaus
Wirth, another pioneer in computer

58
00:04:50.048 --> 00:04:55.438
science, wrote a famous book called
Algorithms + Data Structures = Programs.

59
00:04:55.438 --> 00:05:02.079
[cough]. Another reason nowadays to study
algorithms is that, they have become a

60
00:05:02.079 --> 00:05:08.420
common language for understanding, nature.
Algorithms are computational models, and

61
00:05:08.420 --> 00:05:14.892
algorithmic models are replacing
mathematical models in scientific inquiry.

62
00:05:14.892 --> 00:05:20.287
In the twentieth century, math, scientists
developed mathematical models to try to

63
00:05:20.287 --> 00:05:25.251
understand natural phenomenon. It soon
became clear that those mathematical

64
00:05:25.251 --> 00:05:30.561
models were difficult to solve. It was
difficult to create solutions, to be able

65
00:05:30.561 --> 00:05:36.011
to test hypotheses against natural
phenomenon. So, more and more and more now

66
00:05:36.011 --> 00:05:41.189
a days people are developing computational
models, where they attempt to simulate

67
00:05:41.189 --> 00:05:46.568
what might be happening in nature in order
to try to better understand it. Algorithms

68
00:05:46.568 --> 00:05:52.069
play an extremely important role in this
process. And we'll see some examples of

69
00:05:52.069 --> 00:05:58.009
this in this course. Another important
reason is that if you know effect, how to

70
00:05:58.009 --> 00:06:03.067
effectively use algorithms and data
structures you're going to have a much

71
00:06:03.067 --> 00:06:09.851
better chance at interviewing for a job in
the technology industry then if you don't.

72
00:06:09.851 --> 00:06:15.953
So, here's a bunch of reasons that I just
went through for studying algorithms.

73
00:06:15.953 --> 00:06:21.761
Their impact's broad and far-reaching,
they have old roots and present new

74
00:06:21.761 --> 00:06:26.175
opportunities, they allow us to solve
problems that could not otherwise be

75
00:06:26.175 --> 00:06:30.003
addressed, you can use them for
intellectual stimulation to become a

76
00:06:30.003 --> 00:06:34.049
proficient programmer. They might unlock
the secrets of life in the universe, and

77
00:06:34.049 --> 00:06:38.461
they're good for fun and profit. In fact,
a pr ogrammer might ask, why study

78
00:06:38.461 --> 00:06:42.433
anything else? Well, there's plenty of
good reasons to study other things, but

79
00:06:42.433 --> 00:06:47.557
I'll submit there's no good reason not to
study algorithims. [cough] So, for this

80
00:06:47.557 --> 00:06:53.714
course we have two resources that I want
to talk about and make sure that people

81
00:06:53.714 --> 00:06:59.374
are familiar with before entering into the
content. This is a publishing model that

82
00:06:59.374 --> 00:07:04.472
Kevin Wayne and I developed and have been
using for many years, and we think it's a

83
00:07:04.472 --> 00:07:09.507
very effective way to support the, kinds
of lectures that we're going to be giving

84
00:07:09.507 --> 00:07:14.659
in this course. Down at the bottom, and
it's optional for this course, we have a

85
00:07:14.659 --> 00:07:19.887
text book. It's a traditional, text book
that extensively covers the topics in the

86
00:07:19.887 --> 00:07:24.285
course, in fact many more topics than we
can present in lecture. And then

87
00:07:24.285 --> 00:07:28.668
supporting that textbook, is free online
material that we call the book site. You

88
00:07:28.668 --> 00:07:33.839
can go to books, the book site to see the
lecture slides. But more important,

89
00:07:33.839 --> 00:07:39.967
there's code, there's exercises, tere's a
great deal of information there. In fact,

90
00:07:39.967 --> 00:07:45.329
maybe ten times what's in the book,
including a summary of the content. So,

91
00:07:45.329 --> 00:07:51.211
during this course you'll be referring to
the book site frequently while working

92
00:07:51.211 --> 00:07:57.075
online. People often ask about
prerequisites. We're assuming that people

93
00:07:57.075 --> 00:08:02.820
who take this course know how to program,
and know the basics of loops, arrays,

94
00:08:02.820 --> 00:08:09.307
functions. They have some exposure to
object oriented programming and recursion.

95
00:08:09.307 --> 00:08:15.713
We use the Java language, but we don't
dwell on details of Java, we mostly use it

96
00:08:15.713 --> 00:08:21.546
as an expository language. We do some
math, but not advanced math. If you want

97
00:08:21.546 --> 00:08:27.875
to review the material that we think is
prerequisite for the material in this

98
00:08:27.875 --> 00:08:33.399
course, you can do a quick review by
looking at sections 1.1 and 1.2 of the

99
00:08:33.399 --> 00:08:39.110
book. Either at the book site or in the
text book. If you want an in depth review,

100
00:08:39.110 --> 00:08:43.722
we have a full text book called, An
Introduction to Programming in Java: An

101
00:08:43.722 --> 00:08:49.338
Interdisciplinary Approach. There is a
book site and text book as well. But, the

102
00:08:49.338 --> 00:08:53.968
bottom line is, you should be able t o
program, and the quick exercise to get

103
00:08:53.968 --> 00:08:58.688
ready is, to write a java program on your
computer perhaps using a programming

104
00:08:58.688 --> 00:09:03.287
model, as described on the book site. We
will provide much more detail information

105
00:09:03.287 --> 00:09:07.847
on that as we get into the assignments.
You can use your own programming

106
00:09:07.847 --> 00:09:13.294
environment if your comfortable with one
or you download ours. We have instructions

107
00:09:13.294 --> 00:09:15.039
on the web on how to do that.